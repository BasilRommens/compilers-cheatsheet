\section{Scanning with Regular Languages \& Parsers with CFG}
\subsection*{Scanner}
Splits input in sub-strings and groups in lexical units. Feeds tokenized version of input to parser. \textbf{hand-built scanners:} Beyond regular languages; Easier to debug; More efficient.
\subsection*{Automata}
\textbf{NFA} ($Q,\Sigma,\delta,q_0,F$) $Q \times (\Sigma \cup \{\epsilon \}) \rightarrow 2^Q$ transition func. \textbf{DFA} NFA deterministic if $\delta (q,\epsilon )\ =\ \phi\ \forall\ q\ \in\ Q \wedge\ |\delta(q,a)|\ =\ 1\ \forall\ (q,a)\ \in\ Q\ \times\ \Sigma$. For DFAs, $\delta$ form $Q \times\ \Sigma\ \rightarrow\ Q$. Can detect word w, in $\mathcal{O}(|w|)$ from regex constructed in P-time.
\subsection*{Myhill-Nerode theorem}
\textbf{Equivalence classes:}We say x, y are equivalent with respect to L, written x \textasciitilde$_L$ y if xz $\in$ L $\iff$ yz $\forall\ z \in \Sigma^*$
p> \textbf{theorem:} Language L is regular iff $~_L$ has finite number of equivalence classes. Number of equivalence classes of $~_L$ is number of states of smallest DFA.
\subsection*{recognizing v scanning}
\textbf{Recognizing:} Given string, simulate DFA and get boolean answer: (not) lexeme recognized. \textbf{Scanning:} Given string, scanner returns sequence tokens. Token is longest match (maximal much).
\subsection*{Longest matches}
Find longest prefix of remaining string which is lexical unit. \textbf{2 or more matches:} 1. First will be chosen; 2. Disallow, DFAs cant accept same input. Doing: 1. DFAs ordered; 2. Language checking when generating scanner. For all pairs of EREs with $L_1,L_2$, we should check: $L_1 \cap L_2 = \phi$.
\subsection*{Grammar}
G = (V, T, P, S) P: $\alpha\rightarrow\beta$ with $\alpha \in (V \cup T)^*V(V\cup T)^*$ and $\beta \in (V \cup T)^*$. \textbf{Derivation} Let $\gamma \in (V \cup T)^*V(V \cup T)^*$ and $\delta \in (V \cup T)^*$. We say $\delta$ can be derived from $\gamma$ iff there are $\gamma_1,\gamma_2 \in (V \cup T)*$ and a rule $\alpha \rightarrow \beta \in P$ st $\gamma = \gamma_1 \cdot \alpha \cdot \gamma_2$ and $\delta = \gamma_1 \cdot \beta \cdot \gamma_2$.
\subsection*{Grammar classes}
For all rules $\alpha \rightarrow \beta$: \textit{class 0}: All grammars no restriction; \textit{class 1}: Context-sensitive grammars: either $\alpha = S$ and $\beta = \epsilon$ or $|\alpha| \leqslant |\beta|$ and S does not appear in $\beta$; \textit{class 2}: Context-free grammars: $\alpha \in V$; \textit{class 3}: $\alpha \in V$ and left-regular = $\beta \in T^* \cup (V \cdot T^*)$. right-regular = $\beta \in T^* \cup (T^* \cdot V)$. \textbf{Chomskyâ€™s hierarchy:} Languages: $Reg \subset CFL \subset CSL \subset RE$.
\subsection*{Universality of CNF}
\textbf{CFG to CNF:} Eliminate: 1. Start symbol from RHS; 2. Rules with non-solitary terminals. 3. RHS with more than 2 nonterminals. 4. $\epsilon$ productions; 5. Unit rules. \textbf{splits:} For grammars in CNF, A can generate w if we can find a rule A -> BC and we can split w in two non-empty words w = u $\cdot$ v st: B -> u and C -> v. It does detect w in polynomial time $\mathcal{O}(|w|^3)$
\subsection*{Attributes (semantics)}
We associate to every nonterminal variable V of the grammar a finite set A(V) of attributes partitioned into synthesized attributes $A_s(V)$ and inherited attributes $A_i(V)$. I Each attribute $\alpha \in A(V)$ has a (potentially infinite) set of possible values. The actual value will be selected based on the appearance of V in the derivation tree. \textbf{Attribute mapping functions:} For each rule $\alpha \rightarrow \beta_1 ... \beta_k$ we have a semantic rule functions $f_{\alpha,j}$ mapping values of certain attributes of $\beta_1 ... \beta_k$ to values of $\alpha \in A(\beta_j)$. \textbf{welldefinedness:} Semantic rule should not be recursive. They are formulated in a way st all attributes are always defined at all nodes in all possible derivation trees. \textbf{synthesized/inherited:} synthesized if its value depends on the vaules of its children in some derivation tree, if not the inherited.
\subsection*{(Non)deterministic pushdown automata}
A is a tuple $(Q, \Sigma, \Gamma, \delta, q_0, Z_0, F)$ $\delta : Q \times (\Sigma \cup \{\epsilon\}) \times \Gamma \rightarrow 2^{Q\times\Gamma^*}$ transition func. \textbf{Deterministic:} 1. $\forall q \in Q$, all $a \in \Sigma \cup {\epsilon}$, and all $\gamma \in \Gamma$: $\delta(q,a,\gamma)$ has at most 1 element. 2. $\forall q \in Q$, and all $\gamma \in \Gamma$: if $\delta(q,\epsilon,\gamma) \neq \phi$ then $\delta(q,a,\gamma) = \phi$ for all $a \in \Sigma$, but does not accept CFL $L_{pal}$
\subsection*{Simplifying grammar}
\textbf{Factoring:} $A \rightarrow wB$ and $A \rightarrow wC$, split A into $A_1 \rightarrow wA_2$ and $A_2 \rightarrow B$, $A_2 \rightarrow C$. \textbf{Indirect left recursion:} $\forall$ pairs of rules $A \rightarrow Bw$ and $B \rightarrow \beta_1$ we replace the first rule by $A \rightarrow \beta_1 w$. Repeated. \textbf{Direct left recursion:} If we have rules $(V \rightarrow V \alpha_i)_{i\in I}$ and $(V \rightarrow \beta_j)_{j\in J}$, we can replace them by $(V' \rightarrow \alpha_i )_{i\in I}$, $(V \rightarrow \beta_j V')_{j\in J}$, and $V' \rightarrow \epsilon$. \textbf{unproductive:} A unproductive if there is no word w that can be derived from A. \textbf{unreachable:} $X \in T \cup V$ is unreachable if no sentential form contains X.
