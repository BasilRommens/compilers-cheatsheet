\section{Type checking and other semantic analyses}
\subsection*{Type checking}
Assigning a type t to a variable x is, in essence, an invariant. Because languages are turing complete undecidable. Conservative if static, applies inference rules to deduce types of expression (without caring about reachability). We can use implicit casting if we have expressions of the type 4 + 1.0. The hierarchy is saved in memory.\\
\textbf{Typechecker:} Verify the validity of the expression given the types of the descendants. Derive the type of parent expressions (propagation). Via bottom-up traversal of the AST using the symbol table. Statements have no type, so they start the recursive traversal of their
\subsection*{General reachability}
Undecidable, halting problem. Conservative approach. Focus list of statements, reachable and terminate normally, ie control flow "falls through".\\
\textbf{Algorithm:} Consider a statement list S = s 1 , . . . , s n ;
1. If S is reachable then s 1 is reachable. 2. If s n terminates abnormally then so does S. 3. If S is the body of a function or procedure then S is reachable. 4. Local variable declarations, assignments, function calls, memory allocation, increment, decrement instructions all terminate normally. 5. A null statement or statement list does not generate error messages if it is not reachable. However, they propagate their non-reachability status to their successors. 6. If a statement has a predecessor then it is reachable if its predecessor terminates normally. For reachability analysis we assume the conditioncan be both true and false. \textit{while loop} If it evaluates constant true -> the while-statement is marked as abnormally terminating â€” since it is an infinite loop. false -> unreachable; If body contains break then normal terminating (when was abnormal). If body terminates normally, then the while statement terminates normally (unless infite with no break).
